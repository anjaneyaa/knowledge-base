<h4>Coroutines and Asynchronous Programming in Python</h4>
<p>Coroutines and asynchronous programming in Python allow you to write non-blocking and efficient code for
    I/O-bound tasks, such as network requests, file operations, and database queries. Asynchronous programming
    is particularly useful when you want to achieve concurrency without creating multiple threads or processes.
</p>

<li>Coroutines</li>
<p>Coroutines are a type of function that can pause execution and yield control back to the event loop, allowing
    other tasks to run while waiting for I/O-bound operations to complete.</p>
<pre><code>
async def say_hello():
    print("Hello")
    await asyncio.sleep(1)  # Non-blocking sleep
    print("World")
    </code></pre>

<li>The <code>async</code> and <code>await</code> Keywords</li>
<ul>
    <li><code>async</code>: Used to define a coroutine function.</li>
    <li><code>await</code>: Used to pause execution of the coroutine and wait for the completion of another
        coroutine or asynchronous operation.</li>
</ul>

<li>Asynchronous Event Loop</li>
<p>An event loop is the central component of asynchronous programming. It manages and schedules multiple tasks
    (coroutines) to run concurrently without creating separate threads or processes.</p>
<pre><code>
import asyncio

async def main():
    task1 = asyncio.create_task(say_hello())
    task2 = asyncio.create_task(say_hello())
    await task1
    await task2

asyncio.run(main())
    </code></pre>

<li>Benefits of Asynchronous Programming</li>
<ul>
    <li>Improved I/O performance: Non-blocking I/O operations allow other tasks to run while waiting for data.
    </li>
    <li>Concurrency without threads: Asynchronous programming is more memory-efficient compared to creating
        multiple threads.</li>
    <li>Scalability: Asynchronous code can handle a large number of connections simultaneously.</li>
</ul>

<li>Asynchronous Libraries</li>
<ul>
    <li><code>asyncio</code>: The built-in library for asynchronous programming, providing event loops,
        coroutines, and other asynchronous primitives.</li>
    <li><code>aiohttp</code>: A popular library for asynchronous HTTP requests.</li>
    <li><code>aiomysql</code>, <code>aiopg</code>: Libraries for asynchronous database connections.</li>
</ul>

<li>Using <code>async with</code> and <code>async for</code></li>
<p>In addition to <code>async def</code> and <code>await</code>, Python also provides <code>async with</code>
    and <code>async for</code> to work with asynchronous context managers and iterate over asynchronous
    iterators.</p>
<pre><code>
async with open("file.txt", "r") as file:
    content = await file.read()

async for line in async_file_iterator():
    process(line)
    </code></pre>

<p>Asynchronous programming allows you to write code that efficiently handles I/O-bound tasks and maximizes
    resource utilization. However, it's important to note that asynchronous programming is most beneficial for
    I/O-bound operations; for CPU-bound tasks, other approaches like multiprocessing might be more suitable.</p>